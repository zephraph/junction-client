{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Junction is a control-plane driven client library for service routing, load-balancing, and resilience.</p>"},{"location":"#about","title":"About","text":"<p>Junction is a library that allows you to dynamically configure application level HTTP routing, load balancing, and resilience by writing a few lines of code. Junction is like having a rich HTTP proxy embedded in your client, with deep integrations into the libraries you already use.</p> <p>Junction can be statically configured, with plain old software, or dynamically configured with any gRPC-xDS compatible configuration server. Check out ezbake for a simple server that lets you save Junction config using the Kubernetes Gateway API</p>"},{"location":"#project-status","title":"Project status","text":"<p>Junction is alpha software, developed in the open. We're still iterating rapidly on core code and APIs. At this stage you should expect occasional breaking changes as the library evolves. At the moment, Junction only supports talking to Kubernetes services, with support for routing to any existing DNS name coming very soon.</p>"},{"location":"#features","title":"Features","text":"<p>Junction allows you to statically or dynamically configure:</p> <ul> <li>Routing traffic to backends based on the HTTP method, path, headers, or query parameters.</li> <li>Timeouts</li> <li>Retries</li> <li>Weighted traffic splitting</li> <li>Load balancing</li> </ul> <p>Junction differs from existing libraries and proxies is that we aim to do all of this in your native programming language, with low overhead and deep integration into your existing HTTP client. This approach means that Junction can provide dynamic config, but still provide first class support for things like unit testing and debugging, putting developers back in control of their applications.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>We're starting small and focused with Junction. Our first goal is getting configuration right. Our next goal is allowing you to push configuration that you've developed and tested to a centralized config server.</p>"},{"location":"#supported-languages-and-http-libraries","title":"Supported Languages and HTTP Libraries","text":"Language Core Library Supported HTTP Libraries Rust <code>junction-core</code> None Python <code>junction</code> requests and urllib3"},{"location":"api/","title":"API reference","text":"<p>The API reference contains detailed descriptions of all public functions and objects. It's the best place to look if you need information on a specific function.</p>"},{"location":"api/#python","title":"Python","text":"<p>The Python API reference is built using Sphinx. It's available in our docs.</p>"},{"location":"api/#rust","title":"Rust","text":"<p>The Rust API reference is built using Cargo. It's available in our docs: * API Types * Core API</p>"},{"location":"user-guide/getting-started/","title":"Getting started","text":"<p>Junction clients are part of your application and function as a cache for dynamic configuration. All Junction clients can also be configured with static configuration that acts as a default when a server doesn't have any dynamic configuration for a route or a target. When you make an HTTP request, Junction matches it against existing configuration, decides where and how to send the request, and then hands back control to your HTTP library.</p> <p>In all of our libraries, Junction clients expect to be able to talk to a dynamic configuration server. The details of how you specify which config server to talk to are specific to each language - we want it to feel natural.</p> <p>If you don't already have a gRPC-compatible xDS server available, try installing ezbake in your local Kubernetes cluster.</p>"},{"location":"user-guide/getting-started/#install-ezbake","title":"Install <code>ezbake</code>","text":"<p>NOTE: <code>ezbake</code> is currently not available as a pre-built container. To build and run it, you'll need a working Rust toolchain - we recommend installing rustup if you haven't already.</p> <p>NOTE: <code>ezbake</code> doesn't do anything without a Kubernetes cluster. If you don't have one running, we recommend either using the cluster built into Docker Desktop or OrbStack, or setting up a local cluster with <code>k3s</code>.</p>"},{"location":"user-guide/getting-started/#building-and-running-in-kubernetes","title":"Building and Running in Kubernetes","text":"<p>First, build a container:</p> <pre><code>docker build --tag ezbake --file ./scripts/Dockerfile-develop --load .\n</code></pre> <p>By default <code>ezbake</code> requires permissions to read and watch all services in all namespaces, but can be run in a mode where it only watches a single namespace with the <code>--namespace</code> flag.</p> <p>NOTE: To set up an <code>ezbake</code> with the Gateway APIs and our example policies, you need full administrative access to your cluster. If you don't have full access, see the advanced directions below.</p> <p>The example policies in <code>./scripts/install-for-cluster.yml</code> set up a new namespace named <code>junction</code>, a <code>ServiceAccount</code> with permissions to watch the whole cluster, and an <code>ezbake</code> Deployment.</p> <pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.1.0/standard-install.yaml\nkubectl apply -f ./scripts/install-for-cluster.yml\n</code></pre> <p>NOTE: These policies don't require the Gateway APIs to be defined before they're run, but they won't actually give the ServiceAccount permission to watch or list <code>HTTPRoute</code>s until the Gateway APIs are defined and the RBAC rules are re-created.</p> <p>To connect to your new <code>ezbake</code> with a Junction HTTP Client, use the newly defined Kubernetes Service as your <code>JUNCTION_ADS_SERVER</code>:</p> <pre><code>export JUNCTION_ADS_SERVER=\"grpc://\"`kubectl get svc ezbake --namespace junction -o jsonpath='{.spec.clusterIP}'`\":8008\"\n</code></pre> <p>To uninstall, run <code>kubectl delete</code> on the Gateway APIs and the Junction example objects:</p> <pre><code>kubectl delete -f ./scripts/install-for-cluster.yml\nkubectl delete -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.1.0/standard-install.yaml\n</code></pre> <p>To install <code>ezbake</code> on a k8s cluster where you do not have full k8s administrative access, see the advanced directions below.</p>"},{"location":"user-guide/getting-started/#using-the-client","title":"Using the client","text":""},{"location":"user-guide/getting-started/#python","title":"Python","text":"<p>In Python, Junction is available as a standalone client and as a drop-in replacement for <code>requests.Session</code> or <code>urllib3.PoolManager</code>.</p> <p>Using junction as a drop-in replacement for requests is as easy as:</p> <pre><code>import junction.requests as requests\n\nsession = requests.Session()\nresp = session.get(\"http://my-service.prod.svc.cluster.local\")\n</code></pre> <p>To configure your client, pass <code>default_routes</code> or <code>default_backends</code> to your <code>Session</code>. For example, to load-balance requests to an <code>nginx</code> service in the <code>web</code> namespace based on the <code>x-user</code> header, you can specify:</p> <pre><code>import junction.requests as requests\n\n# create a new Session with a default load balancing policy for the nginx service\nsession = requests.Session(\n    default_backends=[\n        {\n            \"target\": {\"type\": \"service\", \"name\": \"nginx\", \"namespace\": \"web\"},\n            \"lb\": {\n                \"type\": \"RingHash\",\n                \"hash_params\": [\n                    {\"type\": \"Header\", \"name\": \"x-user\"},\n                ],\n            },\n        }\n    ]\n)\n\n# make a request to the nginx service\nsession.get(\"http://nginx.web.svc.cluster.local\")\n</code></pre> <p>Routes can be configured by default as well. To send all requests to <code>/v2/users</code> to a different version of your application, you could set a default configuration like:</p> <pre><code>import junction.config\nimport typing\n\nimport junction.requests as requests\n\nmy_service = {\"type\": \"service\", \"name\": \"cool\", \"namespace\": \"widgets\"}\nmy_test_service = {\"type\": \"service\", \"name\": \"cooler\", \"namespace\": \"widgets\"}\n\n# create a new routing policy.\n#\n# all Junction config comes with python3 type hints, as long as you import junction.config\nroutes: typing.List[junction.config.Route] = [\n    {\n        \"target\": my_service,\n        \"rules\": [\n            {\n                \"backends\": [my_test_service],\n                \"matches\": [{\"path\": {\"value\": \"/v2/users\"}}],\n            },\n            {\n                \"backends\": [my_service],\n                \"retry\": retry_policy,\n                \"timeouts\": timeouts,\n            },\n        ],\n    },\n]\n\n\n# assert that requests with no path go to the cool service like normal\n(_, _, matched_backend) = junction.check_route(\n    routes, \"GET\", \"http://cool.widgets.svc.cluster.local\", {}\n)\nassert matched_backend[\"name\"] == \"cool\"\n\n# assert that requests to /v2/users go to an even cooler service\n(_, _, matched_backend) = junction.check_route(\n    routes, \"GET\", \"http://cool.widgets.svc.cluster.local/v2/users\", {}\n)\nassert matched_backend[\"name\"] == \"cooler\"\n\n# use the routes we just tested in our HTTP client\ns = requests.Session(default_routes=routes)\n</code></pre> <p>For a more complete example configuration see the sample project. It's a runnable example containing routing tables, load balancing, retry policies, and more.</p>"},{"location":"user-guide/getting-started/#nodejs","title":"NodeJS","text":"<p>NodeJS support is coming soon! Please reach out to info@junctionlabs.io if you run NodeJS services and are interested in being an early access design partner.</p>"},{"location":"user-guide/getting-started/#rust","title":"Rust","text":"<p>The core of Junction is written in Rust and is available in the <code>junction-core</code> crate. At the moment, we don't have an integration with an HTTP library available, but you can use the core client to dynamically fetch config and resolve addresses.</p> <p>See the <code>examples</code> directory for an example of how to use junction to resolve an address.</p>"}]}